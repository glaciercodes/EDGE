export default async function handler(req, res) {
    // Set CORS headers
    res.setHeader('Access-Control-Allow-Credentials', true);
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'GET,OPTIONS,PATCH,DELETE,POST,PUT');
    res.setHeader('Access-Control-Allow-Headers', 'X-CSRF-Token, X-Requested-With, Accept, Accept-Version, Content-Length, Content-MD5, Content-Type, Date, X-Api-Version');

    // Handle OPTIONS request for CORS preflight
    if (req.method === 'OPTIONS') {
        res.status(200).end();
        return;
    }

    // Only allow POST requests
    if (req.method !== 'POST') {
        return res.status(405).json({ error: 'Method not allowed' });
    }

    try {
        const { text } = req.body;

        if (!text || typeof text !== 'string') {
            return res.status(400).json({ error: 'Text is required' });
        }

        if (text.trim().length < 100) {
            return res.status(400).json({ error: 'Text must be at least 100 characters long' });
        }

        // Get OpenAI API key from environment variables
        const apiKey = process.env.OPENAI_API_KEY;
        
        if (!apiKey) {
            console.error('OpenAI API key not configured');
            return res.status(500).json({ error: 'Service configuration error' });
        }

        // Analyze the text with OpenAI
        const analysis = await analyzeWithOpenAI(text, apiKey);
        
        res.status(200).json(analysis);
        
    } catch (error) {
        console.error('Error in detection handler:', error);
        res.status(500).json({ 
            error: error.message || 'Internal server error' 
        });
    }
}

async function analyzeWithOpenAI(text, apiKey) {
    const prompt = `Analyze the following text and determine if it was likely generated by AI or written by a human. Consider:
- Writing style and pattern consistency
- Creativity and originality
- Personal experiences or emotions
- Structural complexity
- Common AI writing patterns

Text: "${text.substring(0, 3000)}"

Respond with this exact JSON format only:
{
    "isAI": boolean,
    "confidence": number between 0 and 1,
    "reasoning": "brief explanation of your analysis"
}`;

    try {
        const response = await fetch('https://api.openai.com/v1/chat/completions', {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${apiKey}`,
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                model: 'gpt-3.5-turbo',
                messages: [
                    {
                        role: 'system',
                        content: 'You are an AI content detection expert. Analyze texts and provide JSON responses only.'
                    },
                    {
                        role: 'user',
                        content: prompt
                    }
                ],
                max_tokens: 500,
                temperature: 0.1,
            }),
        });

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(`OpenAI API error: ${errorData.error?.message || 'Unknown API error'}`);
        }

        const data = await response.json();
        const content = data.choices[0]?.message?.content?.trim();
        
        if (!content) {
            throw new Error('No response from AI analysis');
        }

        // Clean the response and parse JSON
        const cleanContent = content.replace(/```json|```/g, '').trim();
        const result = JSON.parse(cleanContent);

        // Validate the response structure
        if (typeof result.isAI !== 'boolean' || typeof result.confidence !== 'number') {
            throw new Error('Invalid response format from AI analysis');
        }

        // Ensure confidence is between 0 and 1
        result.confidence = Math.max(0, Math.min(1, result.confidence));

        return result;

    } catch (error) {
        console.error('OpenAI analysis error:', error);
        
        // Fallback analysis for when OpenAI fails
        return getFallbackAnalysis(text);
    }
}

function getFallbackAnalysis(text) {
    // Simple fallback analysis based on text characteristics
    const words = text.split(/\s+/).length;
    const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0).length;
    const paragraphs = text.split(/\n\s*\n/).filter(p => p.trim().length > 0).length;
    
    const avgSentenceLength = words / Math.max(sentences, 1);
    const avgParagraphLength = sentences / Math.max(paragraphs, 1);
    
    // Basic heuristics (can be improved)
    let aiScore = 0;
    
    // AI text often has more uniform sentence length
    if (avgSentenceLength > 12 && avgSentenceLength < 25) aiScore += 0.3;
    
    // AI text often has moderate paragraph length
    if (avgParagraphLength > 2 && avgParagraphLength < 5) aiScore += 0.2;
    
    // Check for common AI phrases (simplified)
    const aiPhrases = ['as an AI', 'however, it is important', 'in conclusion', 'additionally'];
    const hasAIPhrases = aiPhrases.some(phrase => text.toLowerCase().includes(phrase));
    if (hasAIPhrases) aiScore += 0.3;
    
    // Check for personal pronouns (more common in human writing)
    const personalPronouns = (text.match(/\b(I|me|my|mine|we|us|our|ours)\b/gi) || []).length;
    if (personalPronouns < 3) aiScore += 0.2;
    
    const isAI = aiScore >= 0.5;
    const confidence = Math.min(0.7, 0.3 + aiScore * 0.4); // Cap at 0.7 for fallback
    
    return {
        isAI,
        confidence,
        reasoning: "Analysis based on text patterns (fallback mode)"
    };
}
